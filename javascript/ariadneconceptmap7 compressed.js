
//COPYRIGHT TALCOTT bv THE NETHERLANDS 

function removeWordCloud() { for (c = 1; c < 10 + 1; c++) { ccw[c].style.visibility; ccw[c].style.position = "absolute"; ccw[c].style.visibility = "hidden"; ccw[c].width = 1; ccw[c].height = 1; ccw[c].style.top = 1 + "px"; ccw[c].style.left = 1 + "px" } } function drawItemRates() { cc.onmousedown = ""; cc.onmousemove = ""; document.body.style.overflow = "scroll"; var e = 0; for (var t = 0; t < 5; t++) { if (parseInt(ratedefinition[0][t + 1]) > 0) { e += 1 } } maxItemWidth = 600; lineHeight = 14; var n = 8; var r = 2; var i = 22; var s = mapM + 10; var o = 40; var u = 0; maxWidth = (cc.width - (maxItemWidth + s * 3 + (e - 1) * o)) / e; u = s + i + cardn * (lineHeight + n + r * 2) + s; cc.height = u; cctx.textBaseline = "top"; cctx.textAlign = "start"; cctx.globalAlpha = 1; cctx.clearRect(0, 0, cc.width, cc.height); cctx.lineWidth = 2; cctx.fillStyle = "White"; cctx.fillRect(0, 0, cc.width, cc.height); cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); drawProjectName(); cctx.font = "9pt Calibri"; cctx.fillStyle = itemDotColor; x = s; y = s; wraptextSingleLine(cctx, "items", x, y, maxItemWidth, lineHeight); for (var t = 0; t < e; t++) { x = s + maxItemWidth + o + t * (maxWidth + o); wraptextSingleLine(cctx, ratedefinition[1][t + 1].trim(), x, y, maxItemWidth, lineHeight) } cctx.font = "9pt Calibri"; var a = ""; for (var f = 0; f < cardn; f++) { x = s; y = s + i + f * (lineHeight + n + r * 2); c = s + maxItemWidth + o + e * (maxWidth + o) + s; var l = lineHeight / 4; cctx.lineWidth = 0; cctx.roundRect(x, y, c, lineHeight + 2 * r, l); cctx.fillStyle = "white"; cctx.fill(); cctx.fillStyle = itemDotColor; if (showItemNumber == true) { a = "(" + (f + 1).toString() + ") " } wraptextSingleLine(cctx, a + cardt[f + 1].trim(), x, y + r, maxItemWidth, lineHeight); for (var t = 0; t < e; t++) { if (parseInt(ratedefinition[0][t + 1]) > 0) { x = s + maxItemWidth + o + t * (maxWidth + o); var c = maxWidth * itemrating[f + 1][t + 1] / ratedefinition[0][t + 1]; cctx.roundRect(x, y, maxWidth, lineHeight + 2 * r, l); cctx.fillStyle = "lightgray"; cctx.fill(); cctx.roundRect(x, y + r, c, lineHeight, l); cctx.fillStyle = importanceColorLight; cctx.fill(); cctx.fillStyle = mapFontcolor; wraptextSingleLine(cctx, "(" + itemratingn[f + 1][t + 1] + ")", x + maxWidth, y + r, maxWidth, lineHeight) } } } } function calculateClusterTREE() { cc.onmousedown = ""; cc.onmousemove = ""; clusternShown = clustermaxn; document.body.style.overflow = "scroll"; cctx.textBaseline = "top"; cctx.textAlign = "start"; lineHeight = 12; var e = lineHeight + 10; var t = 22; var n = mapM + 10; maxWidth = 150; var r = 30; var i = ""; var s = 0; var o = 0; var u = 0; var a = 0; var f = 0; var l = 0; var h = 0; yc1 = 0; var p = 0; for (g = 2; g < clusternShown + 1; g++) { var d = n + (g - 2) * (maxWidth + r); var v = 0; var m = 0; var y = 0; if (isNaN(groupsd[g][3]) == false) { if (g > 2) { s = lineHeight * groupsn[groupsd[g][3]][groupsd[g][4]]; v = n + (groupsd[g][3] - 1) * (maxWidth + r); y = groupsY[groupsd[g][3]][groupsd[g][4]]; m = y + s / 2 } u = t + lineHeight * groupsn[g][groupsd[g][1]]; a = t + lineHeight * groupsn[g][groupsd[g][2]] } for (c = 1; c < g + 1; c++) { cctx.fillStyle = mapFillstyle; groupsX[g][c] = d; if (groupsd[g][1] == c || groupsd[g][2] == c) { groupsOld[g][c] = 1; if (groupsd[g][1] == c) { o = u; clusterHeigth1[g][c] = u; groupsY[g][c] = y; groupsOld[g][c] = 1 } if (groupsd[g][2] == c) { o = a; clusterHeigth2[g][c] = a; groupsY[g][c] = y + e + u; groupsOld[g][c] = 2 } } } ccTest } dv.onscroll = drawTree; drawTree() } function drawTree() { getUserClusterNames(); cctx.textBaseline = "top"; cctx.textAlign = "start"; lineHeight = 12; var e = lineHeight + 10; var t = 22; var n = mapM + 10; maxWidth = 150; var r = 30; var s = 5; var o = ""; var u = 0; var a = 0; u = n + t + clusternShown * e + cardn * lineHeight + n; a = n + maxWidth * (clusternShown - 1) + r * (clusternShown - 2) + n; cc.height = u; cc.width = a; cctx.globalAlpha = 1; cctx.clearRect(0, 0, cc.width, cc.height); cctx.lineWidth = 2; cctx.fillStyle = "White"; cctx.fillRect(0, 0, cc.width, cc.height); cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); var f; var l; var h; var p; var d; cctx.fillStyle = mapFontcolor; drawProjectName(); cctx.font = "11pt Calibri"; for (g = 2; g < clusternShown + 1; g++) { f = n + (g - 2) * (maxWidth + r); var v = backM + backM; wraptextSingleLine(cctx, "cluster node " + g, f, v, maxWidth, lineHeight) } for (g = 3; g < clusternShown + 1; g++) { f = n + (g - 2) * (maxWidth + r); l = n + (groupsd[g][3] - 1) * (maxWidth + r); h = groupsY[g][groupsd[g][1]] + clusterHeigth1[g][groupsd[g][1]] / 2; p = groupsY[g][groupsd[g][2]] + clusterHeigth2[g][groupsd[g][2]] / 2; d = groupsY[groupsd[g][3]][groupsd[g][4]] + (t + lineHeight * groupsn[groupsd[g][3]][groupsd[g][4]]) / 2; var m = 200; var y = 30; var b = 4; var w = 3; cctx.lineWidth = w; cctx.strokeStyle = treeLineColor; cctx.fillStyle = treeLineColor; cctx.textBaseline = "middle"; cctx.textAlign = "center"; cctx.font = "14pt Calibri"; cctx.beginPath(); cctx.moveTo(f - s, n + h); cctx.lineTo(l + s - r, n + d); cctx.stroke(); cctx.beginPath(); cctx.moveTo(f - s, n + p); cctx.lineTo(l + s - r, n + d); cctx.stroke(); if (showTreeInMap == true || showClustersInMap == false) { var E = yellowth[g][1].trim(); var S = cctx.measureText(E); m = S.width + 2 * s + w; if (m < maxWidth + 2 * s + w) { m = maxWidth + 2 * s + w } cctx.fillStyle = treeLineColor; cctx.beginPath(); cctx.roundRect(f - m / 2 + maxWidth / 2, n - y / 2 + h, m, y, b); cctx.fill(); cctx.fillStyle = "White"; cctx.fillText(E, f + maxWidth / 2, n + h); E = yellowth[g][2].trim(); S = cctx.measureText(E); m = S.width + 2 * s + w; if (m < maxWidth + 2 * s + w) { m = maxWidth + 2 * s + w } cctx.fillStyle = treeLineColor; cctx.beginPath(); cctx.roundRect(f - m / 2 + maxWidth / 2, n - y / 2 + p, m, y, b); cctx.fill(); cctx.fillStyle = "White"; cctx.fillText(E, f + maxWidth / 2, n + p); if (groupsd[g][3] == 2) { E = yellowth[groupsd[g][3]][groupsOld[groupsd[g][3]][groupsd[g][4]]].trim(); E = yellowth[groupsd[g][3]][groupsOld[groupsd[g][3]][groupsd[g][4]]].trim(); var S = cctx.measureText(E); m = S.width + 2 * s + w; if (m < maxWidth + 2 * s + w) { m = maxWidth + 2 * s + w } cctx.fillStyle = treeLineColor; cctx.beginPath(); cctx.roundRect(l - m / 2 - maxWidth / 2 - r, n - y / 2 + d, m, y, b); cctx.fill(); cctx.fillStyle = "White"; cctx.fillText(E, l - maxWidth / 2 - r, n + d) } } } if (showClustersInMap == true) { for (g = 2; g < clusternShown + 1; g++) { for (c = 1; c < g + 1; c++) { if (groupsd[g][1] == c || groupsd[g][2] == c) { cctx.fillStyle = importanceColor; var x = 1; if (solutionDims == 1) x = (clusterr1[g][c][rateToUse] - 1) / ratedefinition[0][rateToUse]; if (solutionDims == 2) x = (clusterr2[g][c][rateToUse] - 1) / ratedefinition[0][rateToUse]; if (groupsd[g][1] == c) { drawcluster2(groupsX[g][c] - s, n + groupsY[g][c] - s, maxWidth + 2 * s, clusterHeigth1[g][c] + 2 * s, true, 1, 3, 0) } if (groupsd[g][2] == c) { drawcluster2(groupsX[g][c] - s, n + groupsY[g][c] - s, maxWidth + 2 * s, clusterHeigth2[g][c] + 2 * s, true, 1, 3, 0) } cctx.textBaseline = "top"; cctx.textAlign = "start"; cctx.fillStyle = clustersAndDimensionsFontcolor; cctx.font = "bold 11pt Calibri"; if (groupsd[g][1] == c) { yellowh[g][1].style.visibility = "visible"; yellowh[g][1].style.left = -dv.scrollLeft + groupsX[g][c] + "px"; yellowh[g][1].style.top = -dv.scrollTop + n + groupsY[g][c] + 0 * s + "px"; yellowh[g][1].style.width = maxWidth + "px"; yellowh[g][1].style.height = t + "px"; yellowh[g][1].innerText = yellowth[g][1].trim(); wraptextSingleLine(cctx, yellowth[g][1].trim(), groupsX[g][c], n + groupsY[g][c] + 0 * s, maxWidth, lineHeight) } if (groupsd[g][2] == c) { yellowh[g][2].style.visibility = "visible"; yellowh[g][2].style.left = -dv.scrollLeft + groupsX[g][c] + "px"; yellowh[g][2].style.top = -dv.scrollTop + n + groupsY[g][c] + 0 * s + "px"; yellowh[g][2].style.width = maxWidth + "px"; yellowh[g][2].style.height = t + "px"; yellowh[g][2].innerText = yellowth[g][2].trim(); wraptextSingleLine(cctx, yellowth[g][2].trim(), groupsX[g][c], n + groupsY[g][c] + 0 * s, maxWidth, lineHeight) } cctx.font = "9pt Calibri"; cctx.fillStyle = itemDotColor; for (i = 1; i < groupsn[g][c] + 1; i++) { ii = groups[g][c][i]; if (showItemNumber == true) { o = "(" + ii.toString() + ") " } wraptextSingleLine(cctx, o + cardt[ii].trim(), groupsX[g][c], n + t + groupsY[g][c] + 1 * s + (i - 2) * lineHeight, maxWidth, lineHeight) } } } } } } function cardselect(e) { var t = 0; var n = 9999999; var r = 0; var i = 0; startmove = 1; var s = e.pageX - cc.offsetLeft; var o = e.pageY - cc.offsetTop; for (var u = 1; u < cardn + 1; u++) { t = Math.pow(cardx[u] - s, 2) + Math.pow(cardy[u] - o, 2); if (t < n) { n = t; i = u } } if (!itemselect[i]) { itemselect[i] = 0 } if (itemselect[i] == 0) { itemselect[i] = 1; drawNow(false, sheetNumber, solutionDims) } else { itemselect[i] = 0; drawNow(false, sheetNumber, solutionDims) } } function clusterselect(e) { var t = 0; var n = 9999999; var r = 0; var i = 0; clusterxn = e.pageX - cc.offsetLeft; clusteryn = e.pageY - cc.offsetTop; for (var s = 1; s < clustern + 1; s++) { t = Math.pow(clusterx[clustern][s] - clusterxn, 2) + Math.pow(clustery[clustern][s] - clusteryn, 2); if (t < n) { n = t; i = s } } if (clusterxn > backM && clusteryn > backM && clusterxn < cc.width - backM && clusteryn < cc.height - backM) { drawNow(false, sheetNumber, solutionDims); if (clusterxn > mapM) { drawclusteritems(i, (clusterxn - cc.width / 2) / cc.width, (clusteryn - cc.height / 2) / cc.height) } } } function drawclusteritems(e, t, n) { cctx.textAlign = "left"; cctx.fillStyle = itemsAndNamesColor; cctx.strokeStyle = itemsAndNamesColor; cctx.font = "11pt Calibri"; var r = mapM; cctx.fillText("ITEMS", mapM, r); cctx.font = "9pt Calibri"; r += 10; var i = ""; for (var s = 1; s < groupsn[clustern][e] + 1; s++) { if (showItemNumber == true) { i = "(" + groups[clustern][e][s].toString() + ") " } r += 12; cctx.fillText(i + cardt[groups[clustern][e][s]], mapM, r) } cctx.font = "11pt Calibri"; r += 12 + 14; cctx.fillText("CLUSTERNAMES GIVEN BY PARTICIPANTS", mapM, r); cctx.font = "9pt Calibri"; r = r + 10; for (var o = 1; o < clusternamesn + 1; o++) { var u = Math.pow(Math.pow(clusternamesdr[o][1], 2) + Math.pow(clusternamesdr[o][2], 2), .5); var a = t * clusternamesdr[o][1] / u + n * clusternamesdr[o][2] / u; if (a > .5) { r += 12; cctx.fillText(clusternames[o], mapM, r) } } } function drawparticipantsclusterNames(e) { drawconceptmapWORLD(); worldcenterx = cc.width / 2; worldcentery = cc.height / 2; clusterxn = e.pageX - cc.offsetLeft; clusteryn = e.pageY - cc.offsetTop; if (clusterxn > mapM) { rx = .7 * (clusterxn / worldcenterx) - 1; ry = -.7 * (clusteryn / worldcentery - 1); cctx.textAlign = "left"; cctx.fillStyle = "grey"; cctx.strokeStyle = "grey"; cctx.font = "11pt Calibri"; var t = mapM; cctx.fillText("CLUSTERNAMES GIVEN BY PARTICIPANTS", mapM, t); cctx.font = "9pt Calibri"; t = t + 10; var n = 0; for (var r = 1; r < clusternamesn + 1; r++) { var i = Math.pow(Math.pow(clusternamesdr[r][1], 2) + Math.pow(clusternamesdr[r][2], 2), .5); var s = rx * clusternamesdr[r][1] / i + ry * clusternamesdr[r][2] / i; if (s > .5) { t += 12; cctx.fillText(clusternames[r], mapM, t); n += 1 } } if (n == 0) { t += 12; cctx.fillText("none with positive correlations", mapM, t) } } } function clustermeansMAP() { rawDataN = participantn - 1; for (g = 2; g < clusternShown + 1; g++) { for (c = 1; c < g + 1; c++) { var e = 9999; var t = -9999; var n = 9999; var r = -9999; clusterx[g][c] = 0; clustery[g][c] = 0; for (var i = 1; i < groupsn[g][c] + 1; i++) { var s = parseInt(itemrating[i] * 2); if (!s) { s = 5 } if (cardx[groups[g][c][i]] < e - s) e = cardx[groups[g][c][i]] - s; if (cardx[groups[g][c][i]] > t + s) t = cardx[groups[g][c][i]] + s; if (cardy[groups[g][c][i]] < n - s) n = cardy[groups[g][c][i]] - s; if (cardy[groups[g][c][i]] > r + s) r = cardy[groups[g][c][i]] + s; clusterx[g][c] += cardx[groups[g][c][i]]; clustery[g][c] += cardy[groups[g][c][i]] } clusterx[g][c] = clusterx[g][c] / groupsn[g][c]; clustery[g][c] = clustery[g][c] / groupsn[g][c]; clusterxl[g][c] = e; clusteryl[g][c] = n; clusterxw[g][c] = t - e; clusteryw[g][c] = r - n } } } function clusterdistancesMap() { for (g = 2; g < clusternShown + 1; g++) { for (c = 1; c < g + 1; c++) { var e = 9999; var t = -9999; var n = 9999; var r = -9999; clusterxx[g][c] = 0; clusteryy[g][c] = 0; for (var i = 1; i < groupsn[g][c] + 1; i++) { var s = parseInt(itemrating[i][rateToUse] * 2); if (!s) { s = 5 } if (itemxx[groups[g][c][i]] < e - s) { e = itemxx[groups[g][c][i]] - s } if (itemxx[groups[g][c][i]] > t + s) { t = itemxx[groups[g][c][i]] + s } if (itemyy[groups[g][c][i]] < n - s) { n = itemyy[groups[g][c][i]] - s } if (itemyy[groups[g][c][i]] > r + s) { r = itemyy[groups[g][c][i]] + s } clusterxx[g][c] += itemxx[groups[g][c][i]]; clusteryy[g][c] += itemyy[groups[g][c][i]] } clusterxx[g][c] = clusterxx[g][c] / groupsn[g][c]; clusteryy[g][c] = clusteryy[g][c] / groupsn[g][c]; clusterxxl[g][c] = e; clusteryyl[g][c] = n; clusterxxw[g][c] = t - e; clusteryyw[g][c] = r - n } for (c = 1; c < g + 1; c++) { for (c2 = 1; c2 < g + 1; c2++) { clusterdist[g][c][c2] = Math.pow(Math.pow(clusterxx[g][c] - clusterxx[g][c2], 2) + Math.pow(clusteryy[g][c] - clusteryy[g][c2], 2), .5) } } var o = 99999; for (c = 1; c < g + 1; c++) { o = 99999; for (c2 = 1; c2 < g + 1; c2++) { if (c !== c2) { if (clusterdist[g][c][c2] < o) { o = clusterdist[g][c][c2] } } } clusterdist[g][c][0] = o } } } function calculateConceptMAP(e) { var t = -9999; var n = 9999; var r = -9999; var i = 9999; for (var s = 1; s < cardn + 1; s++) { itemxx[s] = itemx[s] * Math.cos(e * Math.PI) - itemy[s] * Math.sin(e * Math.PI); itemyy[s] = itemx[s] * Math.sin(e * Math.PI) + itemy[s] * Math.cos(e * Math.PI) } for (var s = 1; s < cardn + 1; s++) { if (parseFloat(itemxx[s]) > t) { t = itemxx[s] } if (parseFloat(itemxx[s]) < n) { n = itemxx[s] } if (parseFloat(itemyy[s]) > r) { r = itemyy[s] } if (parseFloat(itemyy[s]) < i) { i = itemyy[s] } } for (var o = 1; o < participantn + 1; o++) { partx_orig[o] = participantdr[o][1][rateToUse] * Math.cos(e * Math.PI) - participantdr[o][2][rateToUse] * Math.sin(e * Math.PI); party_orig[o] = participantdr[o][1][rateToUse] * Math.sin(e * Math.PI) + participantdr[o][2][rateToUse] * Math.cos(e * Math.PI) } for (var o = 1; o < participantgroupn + 1; o++) { partgx_orig[o] = participantdrg[o][1][rateToUse] * Math.cos(e * Math.PI) - participantdrg[o][2][rateToUse] * Math.sin(e * Math.PI); partgy_orig[o] = participantdrg[o][1][rateToUse] * Math.sin(e * Math.PI) + participantdrg[o][2][rateToUse] * Math.cos(e * Math.PI) } for (var o = 1; o < participantn + 1; o++) { if (parseFloat(partx_orig[o]) > t) { t = partx_orig[o] } if (parseFloat(partx_orig[o]) < n) { n = partx_orig[o] } if (parseFloat(party_orig[o]) > r) { r = party_orig[o] } if (parseFloat(party_orig[o]) < i) { i = party_orig[o] } } for (var s = 1; s < cardn + 1; s++) { var u = (parseFloat(itemxx[s]) - n) / (t - n); var a = (parseFloat(itemyy[s]) - i) / (r - i); cardx[s] = parseInt(mapM + (cc.width - 2 * mapM) * u); cardy[s] = parseInt(mapM + (cc.height - 2 * mapM) * a) } for (var o = 1; o < participantn + 1; o++) { var u = (parseFloat(partx_orig[o]) - n) / (t - n); var a = (parseFloat(party_orig[o]) - i) / (r - i); partx[o] = parseInt(mapM + (cc.width - 2 * mapM) * u); party[o] = parseInt(mapM + (cc.height - 2 * mapM) * a) } for (var o = 1; o < participantgroupn + 1; o++) { u = (parseFloat(partgx_orig[o]) - n) / (t - n); a = (parseFloat(partgy_orig[o]) - i) / (r - i); partgx[o] = parseInt(mapM + (cc.width - 2 * mapM) * u); partgy[o] = parseInt(mapM + (cc.height - 2 * mapM) * a) } for (var f = 1; f < clusternamesn + 1; f++) { var u = (parseFloat(clusternamesdr[f][1]) - n) / (t - n); var a = (parseFloat(clusternamesdr[f][2]) - i) / (r - i); cnamex[f] = parseInt(mapM + (cc.width - 2 * mapM) * u); cnamey[f] = parseInt(mapM + (cc.height - 2 * mapM) * a) } pXsize = (cc.width - 2 * mapM) / Math.abs(t - n); pYsize = (cc.height - 2 * mapM) / Math.abs(r - i); var u = (0 - n) / (t - n); var a = (0 - i) / (r - i); zeroX = parseInt(mapM + (cc.width - 2 * mapM) * u); zeroY = parseInt(mapM + (cc.height - 2 * mapM) * a); clustermeansMAP() } function drawconceptmap(e) { var t = 5; cc.onmousedown = cardselect; cc.onmousemove = clusterselect; getUserClusterNames(); getUserDimensionNames(); getClusterNamesFromTree(clustern); document.body.style.overflow = "hidden"; cctx.textBaseline = "top"; cctx.textAlign = "start"; cctx.globalAlpha = 1; cctx.clearRect(0, 0, cc.width, cc.height); cctx.lineWidth = 2; cctx.fillStyle = "White"; cctx.fillRect(0, 0, cc.width, cc.height); cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); drawProjectName(); cctx.font = "9pt Calibri"; cctx.beginPath(); cctx.moveTo(zeroX, mapM); cctx.lineTo(zeroX, cc.height - mapM); cctx.strokeStyle = mapFontcolor; cctx.stroke(); cctx.beginPath(); cctx.moveTo(mapM, zeroY); cctx.lineTo(mapM + cc.width - mapM, zeroY); cctx.strokeStyle = mapFontcolor; cctx.stroke(); cctx.lineWidth = 2; if (showRawDistancesInMap == true) { var n = 0; for (var r = 1; r < cardn + 1; r++) { for (var i = r; i < cardn + 1; i++) { n = sortdataraw[r][i]; if (n >= rawDataN) { cctx.beginPath(); cctx.moveTo(cardx[r], cardy[r]); cctx.lineTo(cardx[i], cardy[i]); cctx.lineWidth = n; cctx.strokeStyle = mapFontcolor; cctx.stroke() } } } } var s = .14; if (ShowParticipants == true) { cctx.font = "9pt Calibri"; cctx.fillStyle = mapFontcolor; for (var o = 1; o < participantn + 1; o++) { if (Math.pow(Math.pow(participantdr[o][1][rateToUse], 2) + Math.pow(participantdr[o][2][rateToUse], 2), .5) > s) { cctx.beginPath(); cctx.moveTo(zeroX, zeroY); cctx.lineTo(partx[o], party[o]); cctx.lineWidth = 2; cctx.stroke(); wraptextsign(cctx, partnames[o].trim(), sign(partx_orig[o]) * textM + partx[o], sign(party_orig[o]) * textM / 2 + party[o], sw - 2 * textM, 16, sign(partx_orig[o]) * 1) } } } if (ShowParticipantsGroups == true) { cctx.font = "9pt Calibri"; cctx.fillStyle = mapFontcolor; for (var o = 1; o < participantgroupn + 1; o++) { if (Math.pow(Math.pow(participantdrg[o][1][rateToUse], 2) + Math.pow(participantdrg[o][2][rateToUse], 2), .5) > s) { cctx.beginPath(); cctx.moveTo(zeroX, zeroY); cctx.lineTo(partgx[o], partgy[o]); cctx.lineWidth = 2; cctx.stroke(); wraptextsign(cctx, participantdrgn[o].trim(), sign(partgx_orig[o]) * textM + partgx[o], sign(partgy_orig[o]) * textM / 2 + partgy[o], sw - 2 * textM, 16, sign(partgx_orig[o]) * 1) } } } if (ShowParticipantsGroups == true || ShowParticipants == true) { cctx.save(); cctx.translate(zeroX, zeroY); cctx.scale(1, pYsize / pXsize); cctx.beginPath(); cctx.arc(0, 0, s * pXsize, 0, 2 * Math.PI, false); cctx.restore(); cctx.fillStyle = mapFillstyle; cctx.fill(); cctx.lineWidth = 6; cctx.strokeStyle = mapFontcolor; cctx.stroke() } cctx.fillStyle = "Black"; if (showTreeInMap == true) { var u = zeroX; var a = zeroY; for (g = 2; g < clustern + 1; g++) { if (g > 2) { u = clusterx[groupsd[g][3]][groupsd[g][4]]; a = clustery[groupsd[g][3]][groupsd[g][4]] } var f = 2 + clustern - g; for (l = 1; l < 2 + 1; l++) { var h = clusterx[g][groupsd[g][l]]; var p = clustery[g][groupsd[g][l]]; cctx.lineWidth = f; cctx.strokeStyle = treeLineColor; cctx.fillStyle = treeLineColor; cctx.beginPath(); cctx.moveTo(u, a); cctx.lineTo(h, p); cctx.stroke() } } for (g = 2; g < clustern + 1; g++) { if (g > 2) { u = clusterx[groupsd[g][3]][groupsd[g][4]]; a = clustery[groupsd[g][3]][groupsd[g][4]] } var f = 2 + clustern - g; for (l = 1; l < 2 + 1; l++) { var h = clusterx[g][groupsd[g][l]]; var p = clustery[g][groupsd[g][l]]; var d = 200; var v = 30; var m = 4; cctx.strokeStyle = treeLineColor; cctx.fillStyle = treeLineColor; cctx.textBaseline = "middle"; cctx.textAlign = "center"; cctx.font = "14pt Calibri"; var y = yellowth[g][l].trim(); var b = cctx.measureText(y); d = b.width + f + 2 * t; cctx.beginPath(); cctx.roundRect(h - d / 2, p - v / 2, d, v, m); cctx.fill(); cctx.fillStyle = "White"; cctx.fillText(y, h, p) } } cctx.textBaseline = "top"; cctx.textAlign = "start" } if (showClustersInMap == true) { for (c = 1; c < clustern + 1; c++) { if (clusterType == 1) { drawcluster2(parseInt(clusterxl[clustern][c]), parseInt(clusteryl[clustern][c]), parseInt(clusterxw[clustern][c]), parseInt(clusteryw[clustern][c]), false, 1, 3, (clusterr2[clustern][c][rateToUse] - 1) / ratedefinition[0][rateToUse]) } if (clusterType == 2) { defineanddrawclusterround(c, (clusterr2[clustern][c][rateToUse] - 1) / ratedefinition[0][rateToUse]) } var w = textM + cc.offsetLeft + parseInt(clusterxl[clustern][c]); var E = textM + cc.offsetTop + parseInt(clusteryl[clustern][c]); yellow[c].style.visibility = "visible"; yellow[c].innerText = clusterNameNow[c].trim(); yellow[c].style.fontFamily = "Calibri"; yellow[c].style.fontSize = "22px"; yellow[c].style.left = w + "px"; yellow[c].style.top = E + "px"; yellow[c].style.width = parseInt(clusteryw[clustern][c]) + "px"; yellow[c].style.height = 22 + "px"; cctx.strokeStyle = clustersAndDimensionsFontcolor; cctx.fillStyle = clustersAndDimensionsFontcolor; cctx.font = "bold 16pt Calibri"; wraptext(cctx, clusterNameNow[c].trim(), w, E, 150, 22); if (showItemsInMap == true) { cctx.font = "9pt Calibri"; for (var r = 1; r < groupsn[clustern][c] + 1; r++) { var S = parseInt(itemrating[r][rateToUse] * 2); if (!S) { S = 5 } drawcardclassiccmsimple(groups[clustern][c][r], cardx[groups[clustern][c][r]], cardy[groups[clustern][c][r]], c, S) } } } } showdimensions() } function calculateConceptWORLD(e) { var t = -9999; var n = 9999; var r = -9999; var i = 9999; for (var s = 1; s < cardn + 1; s++) { itemxx[s] = itemx[s] * Math.cos(e * Math.PI) - itemy[s] * Math.sin(e * Math.PI); itemyy[s] = itemx[s] * Math.sin(e * Math.PI) + itemy[s] * Math.cos(e * Math.PI) } for (var s = 1; s < cardn + 1; s++) { cardwx[s] = itemxx[s] / Math.pow(Math.pow(itemxx[s], 2) + Math.pow(itemyy[s], 2), .5); cardwy[s] = itemyy[s] / Math.pow(Math.pow(itemxx[s], 2) + Math.pow(itemyy[s], 2), .5) } for (var o = 1; o < participantn + 1; o++) { partx[o] = participantdr[o][1][rateToUse] * Math.cos(e * Math.PI) - participantdr[o][2][rateToUse] * Math.sin(e * Math.PI); party[o] = participantdr[o][1][rateToUse] * Math.sin(e * Math.PI) + participantdr[o][2][rateToUse] * Math.cos(e * Math.PI) } for (var o = 1; o < participantgroupn + 1; o++) { partgx[o] = participantdrg[o][1][rateToUse] * Math.cos(e * Math.PI) - participantdrg[o][2][rateToUse] * Math.sin(e * Math.PI); partgy[o] = participantdrg[o][1][rateToUse] * Math.sin(e * Math.PI) + participantdrg[o][2][rateToUse] * Math.cos(e * Math.PI) } worldcenterx = cc.width / 2; worldcentery = cc.height / 2; worldsize = cc.width / 5; if (2 * worldsize > cc.height) worldsize = cc.height / 6; for (var u = 2; u < clusternShown + 1; u++) { for (var a = 1; a < u + 1; a++) { clusterwx[u][a] = 0; var f = 0; for (var l = 1; l < groupsn1[u][a] + 1; l++) { var s = groups1[u][a][l]; clusterwx[u][a] += cardwx[s]; f += 1 } clusterwx[u][a] = clusterwx[u][a] / f; var c = 0; var h = 0; var p = 0; var d = 9999; var v = -9999; if (clusterwx[u][a] != 0) { for (var l = 1; l < groupsn1[u][a] + 1; l++) { var s = groups1[u][a][l]; if (cardwx[s] > 0 && cardwy[s] > 0) p = 0 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] > 0 && cardwy[s] < 0) p = 1 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] < 0 && cardwy[s] < 0) p = 1 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] < 0 && cardwy[s] > 0) p = 2 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); graphPositionH[u][a][s] = p; if (p < d) { d = p; h = s } if (p > v) { v = p; c = s } } pilWC[u][a] = d; pihWC[u][a] = v; pilName[u][a] = -.5 * Math.PI + pilWC[u][a]; pihName[u][a] = -.5 * Math.PI + pihWC[u][a]; mxWC3[u][a] = parseFloat(Math.sin(pilWC[u][a] + (pihWC[u][a] - pilWC[u][a]) / 2)); myWC3[u][a] = parseFloat(-Math.cos(pilWC[u][a] + (pihWC[u][a] - pilWC[u][a]) / 2)); mxAbsWC[u][a] = worldcenterx + sign(mxWC3[u][a]) * (worldsize + boxMwithin); myAbsWC[u][a] = worldcentery + myWC3[u][a] * (worldsize + boxMwithin); if (pihWC[u][a] - pilWC[u][a] > Math.PI) { var d = 9999; var v = -9999; for (var l = 1; l < groupsn1[u][a] + 1; l++) { var s = groups1[u][a][l]; if (cardwx[s] > 0 && cardwy[s] > 0) p = 0 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] > 0 && cardwy[s] < 0) p = 1 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] < 0 && cardwy[s] < 0) p = 1 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); if (cardwx[s] < 0 && cardwy[s] > 0) p = 2 * Math.PI + Math.atan(cardwx[s] / cardwy[s]); graphPositionH[u][a][s] = p; if (p > Math.PI) { if (p < d) { d = p; h = s } } if (p < Math.PI) { if (p > v) { v = p; c = s } } } pilWC[u][a] = d; pihWC[u][a] = v; pilName[u][a] = .5 * Math.PI + pilWC[u][a]; pihName[u][a] = .5 * Math.PI + pihWC[u][a]; mxWC3[u][a] = -parseFloat(Math.sin(pilWC[u][a] + (pihWC[u][a] - pilWC[u][a]) / 2)); myWC3[u][a] = -parseFloat(-Math.cos(pilWC[u][a] + (pihWC[u][a] - pilWC[u][a]) / 2)); mxAbsWC[u][a] = worldcenterx + sign(mxWC3[u][a]) * (worldsize + boxMwithin); myAbsWC[u][a] = worldcentery + myWC3[u][a] * (worldsize + boxMwithin) } } } } var m = (cc.width - (2 * worldsize + 2 * boxMwithin + 2 * boxMcorner)) / 2; var g = 10; for (var u = 2; u < clusternShown + 1; u++) { var y = ""; for (var a = 1; a < u + 1; a++) { lenAbsWC[u][a] = 0; for (var l = 1; l < groupsn1[u][a] + 1; l++) { var s = groups1[u][a][l]; cctxTest.font = "9pt Calibri"; if (showItemNumber == true) { y = "(" + s.toString() + ") " } var b = wraptextsign(cctxTest, y + cardt[s].trim(), 0, 0, m, g, sign(cardwx[s])); lenAbsWC[u][a] += wamy + b * wmy } lenAbsWC[u][a] += wamy } for (var w = 0; w < 2; w++) { var E = new Array(u.value); for (var a = 1; a < u + 1; a++) { if (w == 0) { E[a] = mxWC3[u][a] } else { E[a] = -mxWC3[u][a] } } var S = new Array(u.value); var x = new Array(u.value); var T = new Array(u.value); var N = 0; for (var a = 1; a < u + 1; a++) { S[a] = 0; x[a] = 99999; T[a] = 0 } for (var a = 1; a < u + 1; a++) { if (sign(E[a]) > 0) { for (var C = 1; C < u + 1; C++) { if (sign(E[C]) > 0 && T[C] !== 1) { if (myAbsWC[u][C] < x[a]) { x[a] = myAbsWC[u][C]; S[a] = C } } } } T[S[a]] = 1 } var k = 0; var L = 0; for (var a = 1; a < u + 1; a++) { if (sign(E[a]) > 0) { k += lenAbsWC[u][S[a]]; N += 1 } } k = cc.height - k; var A = 0; var O = -1; var M = -1; for (var a = 1; a < u + 1; a++) { if (sign(E[a]) > 0) { A += 1; if (A == 1) { O = k / (N + 1); M = O + lenAbsWC[u][S[a]] } if (A > 1) { O = M + k / (N + 1); M = O + lenAbsWC[u][S[a]] } myAbsWC[u][S[a]] = O } } } } } function drawconceptmapWORLD() { cc.onmousedown = ""; cc.onmousemove = drawparticipantsclusterNames; document.body.style.overflow = "hidden"; getUserClusterNames(); getUserDimensionNames(); getClusterNamesFromTree(clustern); var e = (cc.width - (2 * worldsize + 2 * boxMwithin + 2 * boxMcorner)) / 2; var t = 10; var n = ""; var r = 10; var i = 20; var s = .8; var o = 1.1; var u = (o - 1) * worldsize; cctx.globalAlpha = 1; cctx.clearRect(0, 0, cc.width, cc.height); cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); drawProjectName(); cctx.strokeStyle = mapFontcolor; cctx.fillStyle = mapFillstyle; cctx.lineWidth = 1; cctx.beginPath(); cctx.arc(worldcenterx, worldcentery, worldsize, 0, 2 * Math.PI, false); cctx.fill(); cctx.stroke(); cctx.font = "9pt Calibri"; cctx.textAlign = "start"; cctx.textBaseline = "top"; var a = .14; if (ShowParticipants == true) { for (var f = 1; f < participantn + 1; f++) { if (Math.pow(Math.pow(participantdr[f][1][rateToUse], 2) + Math.pow(participantdr[f][2][rateToUse], 2), .5) > a) { var c = parseFloat(worldcenterx + partx[f] * worldsize * .9); var h = parseFloat(worldcentery + -1 * party[f] * worldsize * .9); cctx.beginPath(); cctx.lineWidth = 1; cctx.moveTo(worldcenterx, worldcentery); cctx.lineTo(c, h); cctx.strokeStyle = mapFontcolor; cctx.stroke(); cctx.fillStyle = mapFontcolor; wraptextsign(cctx, partnames[f].trim(), sign(partx[f]) * textM + c, sign(party[f]) * textM / 2 + h, sw - 2 * textM, 16, sign(partx[f]) * 1) } } } if (ShowParticipantsGroups == true) { for (var f = 1; f < participantgroupn + 1; f++) { if (Math.pow(Math.pow(participantdrg[f][1][rateToUse], 2) + Math.pow(participantdrg[f][2][rateToUse], 2), .5) > a) { var c = parseFloat(worldcenterx + partgx[f] * worldsize * .9); var h = parseFloat(worldcentery + -1 * partgy[f] * worldsize * .9); cctx.beginPath(); cctx.lineWidth = 1; cctx.moveTo(worldcenterx, worldcentery); cctx.lineTo(c, h); cctx.strokeStyle = mapFontcolor; cctx.stroke(); cctx.fillStyle = mapFontcolor; wraptextsign(cctx, participantdrgn[f].trim(), sign(partgx[f]) * textM + c, sign(party[f]) * textM / 2 + h, sw - 2 * textM, 16, sign(partgx[f]) * 1) } } } if (showClustersInMap == true) { smaller = .8 } else { smaller = 1 } if (showTreeInMap == true) { var p = worldcenterx; var d = worldcentery; for (var v = 2; v < clustern + 1; v++) { var m = smaller * v / clustern; var g = smaller * groupsd[v][3] / clustern; if (v > 2) { p = mxWC3[groupsd[v][3]][groupsd[v][4]]; d = myWC3[groupsd[v][3]][groupsd[v][4]] } for (l = 1; l < 2 + 1; l++) { var y = mxWC3[v][groupsd[v][l]]; var b = myWC3[v][groupsd[v][l]]; cctx.strokeStyle = treeLineColor; cctx.fillStyle = treeLineColor; var w = 2 + clustern - v; cctx.lineWidth = w; cctx.beginPath(); cctx.moveTo(worldcenterx + y * g * worldsize, worldcentery + b * g * worldsize); cctx.lineTo(worldcenterx + y * m * worldsize, worldcentery + b * m * worldsize); cctx.stroke(); cctx.textBaseline = "middle"; cctx.textAlign = "center"; if (groupsn1[v][groupsd[v][l]] > 1) { var E = 16; cctx.lineWidth = E; cctx.beginPath(); if (v == 2) { cctx.arc(worldcenterx, worldcentery, m * worldsize, -.5 * Math.PI + pilWC[2][l], -.5 * Math.PI + pihWC[2][l], false) } if (v > 2) { cctx.arc(worldcenterx, worldcentery, m * worldsize, -.5 * Math.PI + pilWC[v][groupsd[v][l]], -.5 * Math.PI + pihWC[v][groupsd[v][l]], false) } cctx.stroke() } } } for (var v = 2; v < clustern + 1; v++) { var m = smaller * v / clustern; if (v > 2) { p = mxWC3[groupsd[v][3]][groupsd[v][4]]; d = myWC3[groupsd[v][3]][groupsd[v][4]] } for (l = 1; l < 2 + 1; l++) { cctx.font = "12pt Calibri"; if (groupsn1[v][groupsd[v][l]] > 1) { cctx.fillStyle = cctx.fillStyle = "White" } else { cctx.fillStyle = treeLineColor } if (v == 2) { drawTextAlongArc(cctx, yellowth[v][l].trim(), worldcenterx, worldcentery, m * worldsize, pilName[2][l], pihName[2][l]) } if (v > 2) { drawTextAlongArc(cctx, yellowth[v][l].trim(), worldcenterx, worldcentery, m * worldsize, pilName[v][groupsd[v][l]], pihName[v][groupsd[v][l]]) } } } } for (var S = 1; S < clustern + 1; S++) { cctx.textBaseline = "top"; cctx.textAlign = "left"; if (showClustersInMap == true) { cctx.font = "14pt Calibri"; cctx.fillStyle = clustersAndDimensionsFontcolor; cctx.strokeStyle = clustersAndDimensionsFontcolor; drawTextAlongArc(cctx, clusterNameNow[S], worldcenterx, worldcentery, worldsize * o, pilName[clustern][S], pihName[clustern][S]); var E = parseInt(worldsize * .2 * (1 - s) * (clusterr1[clustern][S][rateToUse] - 1)); cctx.beginPath(); cctx.arc(worldcenterx, worldcentery, worldsize - E * .5, -.5 * Math.PI + pilWC[clustern][S], -.5 * Math.PI + pihWC[clustern][S], false); cctx.lineWidth = E; cctx.strokeStyle = importanceColor; cctx.stroke(); for (var x = 1; x < groupsn1[clustern][S] + 1; x++) { var T = groups1[clustern][S][x]; radius = parseInt(worldsize * .2 * (1 - s) * itemrating[T][rateToUse]); cctx.strokeStyle = importanceColorLight; cctx.lineWidth = radius; cctx.beginPath(); cctx.arc(worldcenterx, worldcentery, worldsize - radius * .5, -.5 * Math.PI + graphPositionH[clustern][S][T] - .01, -.5 * Math.PI + graphPositionH[clustern][S][T] + .01, false); cctx.stroke() } } var N = new Array(cardn.value); var C = mxAbsWC[clustern][S]; var k = myAbsWC[clustern][S]; var L = worldcenterx + mxWC3[clustern][S] * (worldsize + u); var A = worldcentery + myWC3[clustern][S] * (worldsize + u); cctx.fillStyle = mapFillstyle; cctx.strokeStyle = mapFontcolor; cctx.lineWidth = 1; if (mxAbsWC[clustern][S] > worldcenterx) { drawcluster2(C - wmx, k - wmy, e + 2 * wmx, lenAbsWC[clustern][S] + 2 * wmy, 1, false, 3, 0) } else { drawcluster2(C - (e + wmx), k - wmy, e + 2 * wmx, lenAbsWC[clustern][S] + 2 * wmy, false, 1, 3, 0) } var O = 10; if (mxAbsWC[clustern][S] > worldcenterx) { c = O + C - wmx } else { c = O + C - (e + wmx) } h = k - wmy; yellow[S].innerText = clusterNameNow[S].trim(); yellow[S].style.fontFamily = "Calibri"; yellow[S].style.fontSize = "22px"; yellow[S].style.color = "transparant"; yellow[S].style.visibility = "visible"; yellow[S].style.left = cc.offsetLeft + parseInt(c) + "px"; yellow[S].style.top = cc.offsetTop + parseInt(h) + "px"; yellow[S].style.width = e + "px"; yellow[S].style.height = sh + "px"; var M = 0; for (var x = 1; x < groupsn1[clustern][S] + 1; x++) { var T = groups1[clustern][S][x]; cctx.font = "9pt Calibri"; cctx.fillStyle = itemDotColor; if (showItemNumber == true) { n = "(" + T.toString() + ") " } var _ = wraptextsign(cctx, n + cardt[T].trim(), C, k + M, e, t, sign(mxAbsWC[clustern][S] - worldcenterx)); M += wamy + _ * wmy; var r = worldcenterx + cardwx[T] * (worldsize + 30); var i = worldcentery + cardwy[T] * (worldsize + 30) * -1 } cctx.fillStyle = "black"; cctx.strokeStyle = mapFontcolor; cctx.beginPath(); if (cardwx[groups1[clustern][S][1]] > 0) { cctx.moveTo(C - wmx, k + lenAbsWC[clustern][S] * .5) } else { cctx.moveTo(C + wmx, k + lenAbsWC[clustern][S] * .5) } cctx.lineTo(L, A); cctx.closePath(); cctx.lineWidth = 1; cctx.stroke() } showdimensions(); cctx.font = "9pt Calibri"; cctx.textAlign = "left" } function drawwordcloud() { cc.onmousedown = ""; cc.onmousemove = ""; document.body.style.overflow = "hidden"; var cloudType = 1; getUserClusterNames(); getUserDimensionNames(); getClusterNamesFromTree(clustern); clusterdistancesMap(); cctx.globalAlpha = 1; cctx.clearRect(0, 0, cc.width, cc.height); cctx.lineWidth = 2; cctx.fillStyle = "White"; cctx.fillRect(0, 0, cc.width, cc.height); cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); drawProjectName(); var currentoption = loadExampleData(); removeWordCloud(); for (c = 1; c < clustern + 1; c++) { var xl = clusterxl[clustern][c] + clusterxw[clustern][c] / 2 - .5 * clusterdist[clustern][c][0] * pXsize; var xh = clusterxl[clustern][c] + clusterxw[clustern][c] / 2 + .5 * clusterdist[clustern][c][0] * pXsize; var xw = clusterdist[clustern][c][0] * pXsize; var yl = clusteryl[clustern][c] + clusteryw[clustern][c] / 2 - .5 * clusterdist[clustern][c][0] * pYsize; var yh = clusteryl[clustern][c] + clusteryw[clustern][c] / 2 + .5 * clusterdist[clustern][c][0] * pYsize; var yw = clusterdist[clustern][c][0] * pYsize; cctx.save(); cctx.translate(xl + (xh - xl) / 2, yl + (yh - yl) / 2); cctx.scale(1, pYsize / pXsize); cctx.beginPath(); cctx.arc(0, 0, .5 * clusterdist[clustern][c][0] * pXsize, 0, 2 * Math.PI, false); cctx.restore(); cctx.fillStyle = mapFillstyle; cctx.fill(); cctx.strokeStyle = importanceColor; cctx.lineWidth = parseInt((clusterr2[clustern][c][rateToUse] - 1) * 5); cctx.stroke(); for (var w = 0; w < 1e3; w++) { wordsusedn[w] = 0; wordsused[w] = "" } wordsusednow = 0; var wordNow = ""; for (var i = 1; i < groupsn[clustern][c] + 1; i++) { wordNow = cardt[groups[clustern][c][i]]; wordNow = wordNow.replace("(", " "); wordNow = wordNow.replace(")", " "); wordNow = wordNow.replace(".", " "); wordNow = wordNow.replace(",", " "); wordNow = wordNow.replace(":", " "); wordNow = wordNow.replace(";", " "); wordNow = wordNow.replace("/", " "); addword(wordNow, itemx[i], itemy[i]) } var plus = 0; for (var u = 0; u < wordsusednow; u++) { if (wordsusedn[u] < 2 && wordsused[u].length < 9) { plus += 1 } else { wordsused[u - plus] = wordsused[u]; wordsusedn[u - plus] = wordsusedn[u] } } wordsusednow -= plus; var ccwtx = ccw[c].getContext("2d"); ccw[c].style.position = "absolute"; ccw[c].width = xw; ccw[c].height = yw; ccw[c].style.top = yl + "px"; ccw[c].style.left = xl + "px"; ccw[c].style.visibility = "visible"; ccwtx.clearRect(0, 0, ccw[c].width, ccw[c].height); ccwtx.font = "30pt Calibri"; var textNow = clusterNameNow[c].trim(); var metrics = ccwtx.measureText(textNow); var testWidth = metrics.width; ccwtx.beginPath(); ccwtx.rect(ccw[c].width / 2 - testWidth / 2, ccw[c].height / 2 - 45, testWidth, 35); ccwtx.fillStyle = mapFontcolor; ccwtx.fill(); ccwtx.fillStyle = mapFillstyle; ccwtx.fillText(textNow, ccw[c].width / 2 - testWidth / 2, ccw[c].height / 2 - 15); var options = {}; if (currentoption) { options = function evalOptions() { try { return eval("(" + currentoption + ")") } catch (error) { alert("The following Javascript error occurred in the option definition; all option will be ignored: \n\n" + error.toString()); return {} } }() } options.gridSize = 8; options.weightFactor = 1; options.origin[0] = xw / 2; options.origin[1] = yw / 2; options.fontFamily = "Calibri"; options.color = mapFontcolor; options.backgroundColor = "transparent"; options.clearCanvas = false; options.click = function (e) { alert(e[0] + " N: " + parseInt(Math.pow(e[1] / 12, 2))) }; var list = []; for (var u = 0; u < wordsusednow; u++) { list.push([wordsused[u], 12 * Math.pow(wordsusedn[u], .5)]) } options.list = list; WordCloud(ccw[c], options) } var mapcloud = 0; if (mapcloud == 1) { cctx.lineWidth = 2; cctx.fillStyle = mapFillstyle; cctx.fillRect(backM, backM, cc.width - 2 * backM, cc.height - 2 * backM); drawProjectName(); cctx.font = "9pt Calibri"; for (var w = 0; w < 1e3; w++) { wordsusedn[w] = 0 } wordsusednow = 0; for (var i = 1; i < cardn + 1; i++) { addword(cardt[i], itemx[i], itemy[i]) } for (var r = 1; r < clusternamesn + 1; r++) { addword(clusternames[r], clusternamesdr[r][1], clusternamesdr[r][2]) } var rndm = Math.random(); for (var u = 0; u < wordsusednow; u++) { var sumsq = Math.pow(Math.pow(wordsusedx[u], 2) + Math.pow(wordsusedy[u], 2), .5); if (sumsq > .2) { rndm = (Math.random() - .5) / 7; xx = cc.width / 2 + (rndm + wordsusedx[u]) / wordsusedn[u] * cc.width / 2; yy = cc.height / 2 + (rndm + wordsusedy[u]) / wordsusedn[u] * cc.height / 2; switch (wordsusedn[u]) { case 1: cctx.font = "9pt Calibri"; break; case 2: cctx.font = "11pt Calibri"; break; case 2: cctx.font = "13pt Calibri"; break; case 3: cctx.font = "15pt Calibri"; break; case 4: cctx.font = "17pt Calibri"; break } cctx.fillText(wordsused[u], xx, yy); cctx.font = "19pt Calibri" } } } cctx.font = "9pt Calibri" } function addword(e, t, n) { var r = 0; var i = e.split(" "); for (var s = 0; s < i.length; s++) { r = 0; i[s] = i[s].trim().toLowerCase(); if (checkword(i[s]) != 1) { for (var o = 0; o <= wordsusednow; o++) { if (wordsused[o] == i[s]) { wordsusedn[o] += 1; wordsusedx[o] += t; wordsusedy[o] += n; r = 1 } } if (r == 0) { wordsusednow += 1; wordsusedn[wordsusednow] = 1; wordsused[wordsusednow] = i[s]; wordsusedx[wordsusednow] = t; wordsusedy[wordsusednow] = n } } } } function checkword(e, t, n) { var r = 0; var i = "en"; i = "en"; if (e.length < 4) { r = 1 } else { if (i == "nl") { switch (e) { case "zijn": r = 1; break; case "wordt": r = 1; break; case "het": r = 1; break; case "word": r = 1; break; case "een": r = 1; break; case "niet": r = 1; case "mate": r = 1; case "voor": r = 1; case "achter": r = 1; case "nee": r = 1; break; case "met": r = 1; break; case "ten": r = 1; break; case "dan": r = 1; break; case "heeft": r = 1; break; case "aan": r = 1; break; case "van": r = 1; break; case "was": r = 1; break; case "over": r = 1; break; case "langs": r = 1; break; case "door": r = 1; break; case "tussen": r = 1; break; case "alles": r = 1; break; case "erop": r = 1; break; case "eraan": r = 1; break; case "kan": r = 1; break } } if (i == "en") { switch (e) { case "": r = 1; break; case "the": r = 1; break; case "them": r = 1; break; case "with": r = 1; break; case "there": r = 1; break; case "what": r = 1; break; case "made": r = 1; break; case "not": r = 1; break; case "were": r = 1; break; case "make": r = 1; break; case "takr": r = 1; break; case "you": r = 1; break; case "and": r = 1; break; case "from": r = 1; break; case "for": r = 1; break; case "was": r = 1; break; case "their": r = 1; break } } } return r } function showdimensions() { var e = 300; var t = 16; var n = 2; for (d = 1; d < 4 + 1; d++) { yellow[clustermaxn + d].style.visibility = "visible"; yellow[clustermaxn + d].style.width = e + "px"; yellow[clustermaxn + d].style.height = t + "px" } yellow[clustermaxn + 1].className = "dimtext"; yellow[clustermaxn + 1].innerText = yellowt[clustermaxn + 1]; yellow[clustermaxn + 1].style.top = (cc.height - 0) / 2 + "px"; yellow[clustermaxn + 1].style.left = 4 * n - e / 2 + "px"; yellow[clustermaxn + 1].style.textAlign = "center"; yellow[clustermaxn + 2].className = "dimtext"; yellow[clustermaxn + 2].innerText = yellowt[clustermaxn + 2]; yellow[clustermaxn + 2].style.top = (cc.height - 0) / 2 + "px"; yellow[clustermaxn + 2].style.left = cc.width - (4 * n + e / 2) + "px"; yellow[clustermaxn + 2].style.textAlign = "center"; yellow[clustermaxn + 3].innerText = yellowt[clustermaxn + 3]; yellow[clustermaxn + 3].style.top = n + "px"; yellow[clustermaxn + 3].style.left = (cc.width - e) / 2 + "px"; yellow[clustermaxn + 3].style.textAlign = "center"; yellow[clustermaxn + 4].innerText = yellowt[clustermaxn + 4]; yellow[clustermaxn + 4].style.top = cc.height - (n + t) + "px"; yellow[clustermaxn + 4].style.left = (cc.width - e) / 2 + "px"; yellow[clustermaxn + 4].style.textAlign = "center"; cctx.strokeStyle = "black"; cctx.fillStyle = "black"; cctx.textBaseline = "top"; cctx.textAlign = "start"; cctx.font = "bold  11pt Calibri"; cctx.fillStyle = clustersAndDimensionsFontcolor; cctx.save(); cctx.translate(t, (cc.height - 0) / 2); cctx.rotate(Math.PI / 2); cctx.textAlign = "center"; cctx.fillText(yellowt[clustermaxn + 1].trim(), 0, 0); cctx.restore(); cctx.save(); cctx.translate(cc.width - 0, (cc.height - 0) / 2); cctx.rotate(Math.PI / 2); cctx.textAlign = "center"; cctx.fillText(yellowt[clustermaxn + 2].trim(), 0, 0); cctx.restore(); cctx.textAlign = "center"; var r = cctx.measureText(yellowt[clustermaxn + 3]); var i = r.width; wraptext(cctx, yellowt[clustermaxn + 3], (cc.width - 0) / 2, n, e, t); var r = cctx.measureText(yellowt[clustermaxn + 4]); var i = r.width; wraptext(cctx, yellowt[clustermaxn + 4], (cc.width - 0) / 2, cc.height - (n + t), e, t) } function defineanddrawclusterround(e, t) { var n = 9999; var r = -9999; var i = 9999; var s = -9999; var o = new Array(101); var u = new Array(101); var a = new Array(101); var f = new Array(101); var l = new Array(101); var c = new Array(101); var h = new Array(101); var p = new Array(101); for (var d = 1; d <= 100; d++) { o[d] = 9999; a[d] = -9999; f[d] = 9999; l[d] = 9999; c[d] = -9999 } var v = 0; var m = 0; var g = 0; var y = 0; for (var b = 1; b < groupsn[clustern][e] + 1; b++) { v += cardx[groups[clustern][e][b]]; m += cardy[groups[clustern][e][b]]; y += 1 } v = v / y; m = m / y; if (v != 0) { for (var b = 1; b < groupsn[clustern][e] + 1; b++) { if (cardx[groups[clustern][e][b]] < n) n = cardx[groups[clustern][e][b]]; if (cardx[groups[clustern][e][b]] > r) r = cardx[groups[clustern][e][b]]; if (cardy[groups[clustern][e][b]] < i) i = cardy[groups[clustern][e][b]]; if (cardy[groups[clustern][e][b]] > s) s = cardy[groups[clustern][e][b]]; for (var d = 1; d <= 100; d++) { var w = (cardx[groups[clustern][e][b]] - v) * Math.cos(2 * d / 100 * Math.PI) - (cardy[groups[clustern][e][b]] - m) * Math.sin(2 * d / 100 * Math.PI); var E = (cardx[groups[clustern][e][b]] - v) * Math.sin(2 * d / 100 * Math.PI) + (cardy[groups[clustern][e][b]] - m) * Math.cos(2 * d / 100 * Math.PI); var S = sign(w) * 10; var x = sign(E) * 10; w = w + S; if (w < o[d]) { o[d] = w; u[d] = groups[clustern][e][b]; f[d] = E } if (E < l[d]) l[d] = E } } for (var d = 1; d <= 100; d++) { h[d] = o[d] * Math.cos(-2 * d / 100 * Math.PI) - f[d] * Math.sin(-2 * d / 100 * Math.PI); p[d] = o[d] * Math.sin(-2 * d / 100 * Math.PI) + f[d] * Math.cos(-2 * d / 100 * Math.PI); h[d] = h[d] + v; p[d] = p[d] + m } for (var d = 5; d <= 96; d++) { h[d] = (h[d - 2] + h[d - 1] + h[d] + h[d + 1] + h[d + 2]) / 5; p[d] = (p[d - 2] + p[d - 1] + p[d] + p[d + 1] + p[d + 2]) / 5 } for (var d = 1; d <= 100; d++) { } if (n != 9999) drawclusterround2(e, h, p, v, m, t) } } function drawcluster(e, t, n, r, i, s, o) { var u = 20; var a = parseInt(o * u); cctx.fillStyle = importanceColor; var f = 5; cctx.beginPath(); switch (s) { case 1: cctx.straightRect(e, t, n, r); break; case 2: cctx.singleRoundRect(e, t, n, r, f); break; case 3: cctx.roundRect(e, t, n, r, f); break; default: } cctx.lineWidth = a; cctx.strokeStyle = Importancecolor; cctx.stroke(); cctx.beginPath(); switch (s) { case 1: cctx.straightRect(e - a, t - a, 2 * a + n, 2 * a + r); break; case 2: cctx.singleRoundRect(e - a, t - a, 2 * a + n, 2 * a + r, f); break; case 3: cctx.roundRect(e - a, t - a, 2 * a + n, 2 * a + r, f); break; default: } cctx.fillStyle = "White"; cctx.fill() } function drawcluster2(e, t, n, r, i, s, o, u) { var a = 20; var f = parseInt(u * a); cctx.fillStyle = importanceColor; var l = 5; if (n <= 2 * f) n = 2 * f; if (r <= 2 * f) r = 2 * f; cctx.beginPath(); cctx.lineWidth = f; switch (o) { case 1: cctx.straightRect(e + f, t + f, n - 2 * f, r - 2 * f); break; case 2: cctx.singleRoundRect(e + f, t + f, n - 2 * f, r - 2 * f, l); break; case 3: cctx.roundRect(e - f, t - f, n + 2 * f, r + 2 * f, l); break; default: } cctx.strokeStyle = importanceColor; cctx.stroke(); if (i == true) { cctx.beginPath(); switch (o) { case 1: cctx.straightRect(e, t, n, r); break; case 2: cctx.singleRoundRect(e, t, n, r, l); break; case 3: cctx.roundRect(e, t, n, r, l); break; default: } cctx.fillStyle = mapFillstyle; cctx.fill() } } function drawclusterround(e, t, n) { if (e) { cctx.fillStyle = importanceColor; cctx.beginPath(); cctx.moveTo(t[r], n[r]); for (var r = 1; r <= 100; r++) { cctx.lineTo(t[r], n[r]) } cctx.closePath(); cctx.fill(); cctx.lineWidth = 2; cctx.strokeStyle = "black"; cctx.stroke(); cctx.shadowOffsetX = 0; cctx.shadowOffsetY = 0; cctx.shadowBlur = 0; cctx.shadowColor = "transparent" } } function drawclusterround2(e, t, n, r, i, s) { if (e) { cctx.beginPath(); cctx.moveTo(t[o], n[o]); for (var o = 1; o <= 100; o++) { cctx.lineTo(t[o], n[o]) } cctx.closePath(); cctx.lineWidth = parseInt(s * 20); cctx.strokeStyle = importanceColor; cctx.stroke(); var u = sw - 2 * textM; var a = sh - 2 * textM; yellow[e].style.visibility = "visible"; yellow[e].style.left = textM + cc.offsetLeft + parseInt(r) - u / 2 + "px"; yellow[e].style.top = textM + cc.offsetTop + parseInt(i) - a / 2 + "px"; yellow[e].style.width = u + "px"; yellow[e].style.height = a + "px" } } function drawcardclassiccm(e, t, n, r, i) { if (e) { var s = .5 * Math.PI; var o = 2 * Math.PI; var u = false; cctx.beginPath(); cctx.arc(t, n, i, s, o, u); cctx.lineTo(t, n); cctx.closePath(); cctx.fillStyle = "grey"; if (r == 0) { cctx.fillStyle = "yellow" } if (r == 1) { cctx.fillStyle = "grey" } if (r == 2) { cctx.fillStyle = "blue" } if (r == 3) { cctx.fillStyle = "green" } if (r == 4) { cctx.fillStyle = "DarkKhaki" } if (r == 5) { cctx.fillStyle = "FireBrick" } if (r == 6) { cctx.fillStyle = "YellowGreen " } if (r == 7) { cctx.fillStyle = "orange" } if (r == 8) { cctx.fillStyle = "DarkSalmon" } if (r == 9) { cctx.fillStyle = "CornflowerBlue" } if (r == 10) { cctx.fillStyle = "red" } if (r == 11) { cctx.fillStyle = "DarkSlateGray " } if (r == 12) { cctx.fillStyle = "CadetBlue" } if (r == 13) { cctx.fillStyle = "DarkRed" } if (r == 14) { cctx.fillStyle = "MediumAquaMarine" } if (r == 15) { cctx.fillStyle = "pink" } cctx.fill(); cctx.lineWidth = 1; cctx.strokeStyle = "black"; cctx.stroke(); cctx.fillStyle = "black"; cctx.textBaseline = "top"; cctx.textAlign = "start"; if (showItemNumber == false) { if (itemselect[e] == 1) { wraptext(cctx, cardt[e], t + i, n + i, sw - 2 * textM, 16) } } if (showItemNumber == true) { wraptext(cctx, e.toString(), t + i, n + i, sw - 2 * textM, 16) } } } function drawcardclassiccmsimple(e, t, n, r, i) { if (e) { var s = .5 * Math.PI; var o = 2 * Math.PI; var u = false; cctx.beginPath(); cctx.arc(t, n, i, s, o, u); cctx.lineTo(t, n); cctx.closePath(); cctx.fillStyle = "grey"; cctx.fillStyle = itemDotColor; cctx.fill(); cctx.lineWidth = 1; cctx.shadowOffsetX = 0; cctx.shadowOffsetY = 0; cctx.shadowBlur = 0; cctx.shadowColor = "transparent"; cctx.textBaseline = "top"; cctx.textAlign = "start"; if (showItemNumber == false) { if (itemselect[e] == 1) { wraptext(cctx, cardt[e], t + 4, n, sw - 2 * textM, 16) } } if (showItemNumber == true) { wraptext(cctx, e.toString(), t + 4, n, sw - 2 * textM, 16) } } } function createyellows() { var e = document; for (var t = 1; t < clustermaxn + 5; t++) { yellow[t] = document.createElement("textarea"); yellow[t] = dv.appendChild(yellow[t]); if (t < 10) bbt = "yellow0" + t; if (t > 9) bbt = "yellow" + t; yellow[t].id = bbt; if (t < 10) { yellow[t] = document.getElementById("yellow0" + t) } else { yellow[t] = document.getElementById("yellow" + t) } yellow[t].style.position = "absolute"; yellow[t].style.backgroundColor = "transparent"; yellow[t].style.width = "1px"; yellow[t].style.height = "1px"; yellow[t].style.overflow = "hidden"; yellow[t].style.borderStyle = "none"; yellow[t].style.padding = "0px"; yellow[t].style.fontFamily = "Calibri"; yellow[t].style.fontSize = "14px"; yellow[t].cols = 1; yellow[t].rows = 1; yellow[t].onclick = makeClusterNameVisible; yellow[t].onmouseleave = saveUserClusterNamesFromMap; yellow[t].style.color = "transparent" } } function createyellows2() { var e = document; for (var t = 1; t < clustermaxn + 1; t++) { for (var n = 1; n < 2 + 1; n++) { yellowh[t][n] = document.createElement("textarea"); yellowh[t][n] = dv.appendChild(yellowh[t][n]); if (t < 10) bbt = "yellowt0" + t + n; if (t > 9) bbt = "yellowt" + t + n; yellowh[t][n].id = bbt; yellow[t].style.visibility = "hidden"; if (t < 10) { yellowh[t][n] = document.getElementById("yellowt0" + t + n) } else { yellowh[t][n] = document.getElementById("yellowt" + t + n) } yellowh[t][n].style.position = "absolute"; yellowh[t][n].style.backgroundColor = "transparent"; yellowh[t][n].style.width = "1px"; yellowh[t][n].style.height = "1px"; yellowh[t][n].style.overflow = "hidden"; yellowh[t][n].style.borderStyle = "none"; yellowh[t][n].style.padding = "0px"; yellowh[t][n].style.fontFamily = "Calibri"; yellowh[t][n].style.fontSize = "14px"; yellowh[t][n].cols = 1; yellowh[t][n].rows = 1; yellowh[t][n].onclick = makeClusterNameVisibleH; yellowh[t][n].onmouseleave = saveUserClusterNamesFromTree; yellowh[t][n].style.color = "transparent" } } } function hideYellows() { for (var e = 1; e < clustermaxn + 5; e++) { yellow[e].style.visibility = "hidden" } for (var e = 1; e < clustermaxn + 1; e++) { for (var t = 1; t < 2 + 1; t++) { yellowh[e][t].style.visibility = "hidden" } } } function saveUserClusterNamesFromVar() { var e = ""; for (var t = 0; t < clustermaxn; t++) { e += fixedLength(yellowth[t + 1][1], 90) + fixedLength(yellowth[t + 1][2], 90) } MapCN.value = e; var e = ""; e += fixedLength(yellowt[clustermaxn + 1], 90); e += fixedLength(yellowt[clustermaxn + 2], 90); e += fixedLength(yellowt[clustermaxn + 3], 90); e += fixedLength(yellowt[clustermaxn + 4], 90); MapDN.value = e; saveMapNamesToServer() } function makeClusterNameVisible() { var e = this.id; var t = parseInt(e.substr(6, 2)); yellow[t].style.color = "red"; if (t > clustermaxn) { yellow[t].style.backgroundColor = "white" } } function makeClusterNameVisibleH() { var e = this.id; var t = parseInt(e.substr(7, 2)); var n = e.substr(9, 1); yellowh[t][n].style.color = "red" } function saveUserClusterNamesFromTree() { var e = ""; for (var t = 0; t < clustermaxn; t++) { yellowth[t + 1][1] = yellowh[t + 1][1].innerText; yellowth[t + 1][2] = yellowh[t + 1][2].innerText; yellowh[t + 1][1].style.color = "transparent"; yellowh[t + 1][2].style.color = "transparent" } saveUserClusterNamesFromVar(); drawTree() } function saveUserClusterNamesFromMap() { var e = ""; for (var t = 0; t < clustern; t++) { yellowth[mapClusersFromG[t + 1]][mapClusersFromR[t + 1]] = yellow[t + 1].innerText; yellowt[t + 1] = yellow[t + 1].innerText; yellow[t + 1].style.color = "transparent"; yellow[t + 1].style.backgroundColor = "transparent" } saveUserDimensionNames(); saveUserClusterNamesFromVar() } function getUserClusterNames() { var e = ""; for (var t = 0; t < clustermaxn; t++) { yellowth[t + 1][1] = MapCN.value.substr(t * 180, 90).trim(); yellowth[t + 1][2] = MapCN.value.substr(t * 180 + 90, 90).trim(); yellowh[t + 1][1].innerText = yellowth[t + 1][1]; yellowh[t + 1][2].innerText = yellowth[t + 1][2] } } function saveUserDimensionNames() { yellowt[clustermaxn + 1] = yellow[clustermaxn + 1].innerText; yellow[clustermaxn + 1].style.color = "transparent"; yellow[clustermaxn + 1].style.backgroundColor = "transparent"; yellowt[clustermaxn + 2] = yellow[clustermaxn + 2].innerText; yellow[clustermaxn + 2].style.color = "transparent"; yellow[clustermaxn + 2].style.backgroundColor = "transparent"; yellowt[clustermaxn + 3] = yellow[clustermaxn + 3].innerText; yellow[clustermaxn + 3].style.color = "transparent"; yellow[clustermaxn + 3].style.backgroundColor = "transparent"; yellowt[clustermaxn + 4] = yellow[clustermaxn + 4].innerText; yellow[clustermaxn + 4].style.color = "transparent"; yellow[clustermaxn + 4].style.backgroundColor = "transparent" } function getUserDimensionNames() { yellowt[clustermaxn + 1] = MapDN.value.substr(0 * 90, 90).trim(); yellowt[clustermaxn + 2] = MapDN.value.substr(1 * 90, 90).trim(); yellowt[clustermaxn + 3] = MapDN.value.substr(2 * 90, 90).trim(); yellowt[clustermaxn + 4] = MapDN.value.substr(3 * 90, 90).trim(); yellow[clustermaxn + 1].innerText = yellowt[clustermaxn + 1]; yellow[clustermaxn + 2].innerText = yellowt[clustermaxn + 2]; yellow[clustermaxn + 3].innerText = yellowt[clustermaxn + 3]; yellow[clustermaxn + 4].innerText = yellowt[clustermaxn + 4] } function getClusterNamesFromTree(e) { var t = new Array(clustermaxn); var n = new Array(clustermaxn); for (var r = 1; r < clustermaxn + 1; r++) { clusterNameNow[r] = "" } for (var r = 1; r < clustermaxn + 1; r++) { t[r] = new Array(3) } for (var i = 2; i < e; i++) { t[i][1] = ""; t[i][2] = ""; for (var s = 1; s < groupsn[i][groupsd[i][1]] + 1; s++) { t[i][1] += groups[i][groupsd[i][1]][s] + "." } for (var s = 1; s < groupsn[i][groupsd[i][2]] + 1; s++) { t[i][2] += groups[i][groupsd[i][2]][s] + "." } } for (c = 1; c < e + 1; c++) { n[c] = ""; for (var s = 1; s < groupsn[e][c] + 1; s++) { n[c] += groups[e][c][s] + "." } } for (c = 1; c < e + 1; c++) { if (groupsd[e][1] == c) { clusterNameNow[c] = yellowth[e][1]; mapClusersFromG[c] = e; mapClusersFromR[c] = 1 } if (groupsd[e][2] == c) { clusterNameNow[c] = yellowth[e][2]; mapClusersFromG[c] = e; mapClusersFromR[c] = 2 } if (groupsd[e][1] != c && groupsd[e][2] != c) { for (var i = e - 1; i > 1; i--) { if (n[c] == t[i][1]) { clusterNameNow[c] = yellowth[i][1]; mapClusersFromG[c] = i; mapClusersFromR[c] = 1 } if (n[c] == t[i][2]) { clusterNameNow[c] = yellowth[i][2]; mapClusersFromG[c] = i; mapClusersFromR[c] = 2 } } } } } function drawNow(e, t, n) { function r() { document.body.width = w3; document.body.height = h3; document.body.style.top = "0px"; document.body.style.left = "0px"; document.forms[0].width = w3; document.forms[0].height = h3; document.forms[0].style.top = "0px"; document.forms[0].style.left = "0px"; cc.width = w3; cc.height = h3; cc.style.top = "0px"; cc.style.left = "0px" } function i() { document.body.width = w3; document.body.style.top = "0px"; document.body.style.left = "0px"; document.forms[0].width = w3; document.forms[0].style.top = "0px"; document.forms[0].style.left = "0px"; cc.width = w3; cc.style.top = "0px"; cc.style.left = "0px" } w3 = $(window).width(); h3 = $(window).height(); redrawbuttons(w3, h3, mapM); showMenuManual(); controls.enabled = false; if (e == true) { readdataall() } if (sheetNumber == 0) { removeWordCloud(); i(); drawItemRates(); UploadPic() } if (sheetNumber == 1) { removeWordCloud(); calculateClusterTREE(); drawTree(); UploadPic() } if (sheetNumber == 2) { if (n == 1) { radius = 4; r(); removeWordCloud(); if (e == true) { calculateConceptWORLD(rotateangle) } drawconceptmapWORLD(); if (e == true) { UploadPic() } } if (n == 2) { radius = 8; r(); if (e == true) { calculateConceptMAP(rotateangle) } drawconceptmap(1); if (e == true) { UploadPic() } } if (n == 3) { controls.enabled = true; drawconceptmap3dWorld() } } if (sheetNumber == 3) { if (n == 2) { radius = 4; r(); if (e == true) { calculateConceptMAP(rotateangle) } drawwordcloud(); if (e == true) { UploadPic() } } } } function fixedLength(e, t) { t = t < 0 ? 0 : t; e = e.substr(0, t); var n = []; n.length = t - e.length + 1; return e + n.join(" ") } function UploadPic() { var e = document.getElementById("MapCanvas").toDataURL("image/png"); e = e.replace(/^data:image\/(png|jpg);base64,/, ""); $.ajax({ type: "POST", url: "AriadneConceptSelectedMap.aspx/UploadPic", data: '{ "imageData" : "' + e + '" }', contentType: "application/json; charset=utf-8", dataType: "json", success: function (e) { }, error: function (e) { alert("failure to save image to server: " + e) } }) } function saveMapNamesToServer() { var e = {}; e.activeSelectionS = activesel.value; e.subTitle = dpns.value; e.clusterNames = MapCN.value; e.dimensionNames = MapDN.value; $.ajax({ type: "POST", url: "AriadneConceptSelectedMap.aspx/saveMapNamesToServer", data: JSON.stringify(e), contentType: "application/json; charset=utf-8", dataType: "json", success: function (e) { }, error: function (e) { alert("failure to save clusternames: " + e) } }) } function drawProjectName() { if (showMapTitle == true) { cctx.font = "11pt Calibri"; var e = projectName + ": " + projectSubTitle + " "; if (rateToUse == 1) { e = e + " (rating: " + ratedefinition[1][1] + ")" } if (rateToUse == 2) { e = e + " (rating: " + ratedefinition[1][2] + ")" } if (rateToUse == 3) { e = e + " (rating: " + ratedefinition[1][3] + ")" } if (rateToUse == 4) { e = e + " (rating: " + ratedefinition[1][4] + ")" } if (rateToUse == 5) { e = e + " (rating: " + ratedefinition[1][5] + ")" } var t = cctx.measureText(e); var n = t.width; cctx.fillStyle = mapFontcolor; cctx.fillText(e, cc.width - n - mapM, 2) } } var mapM = 50; var backM = 20; var textM = 10; var sw = 160; var sh = 120; var w3 = 0; var h3 = 0; var colorspectrum = 3; if (colorspectrum == 1) { var mapFillstyle = "Cornsilk"; var mapFontcolor = "FireBrick"; var importanceColorLight = "Tomato"; var importanceColor = "red"; var itemDotColor = "DarkRed"; var treeLineColor = "Coral"; var itemsAndNamesColor = "Blue"; var clustersAndDimensionsFontcolor = "Coral" } if (colorspectrum == 2) { var mapFillstyle = "LightYellow"; var mapFontcolor = "FireBrick"; var importanceColorLight = "Tomato"; var importanceColor = "red"; var itemDotColor = "DarkRed"; var treeLineColor = "DarkOrange"; var itemsAndNamesColor = "Blue"; var clustersAndDimensionsFontcolor = "Orange" } if (colorspectrum == 3) { var mapFillstyle = "LightYellow"; var mapFontcolor = "Chocolate"; var importanceColorLight = "Red"; var importanceColor = "DarkRed"; var itemDotColor = "Chocolate"; var treeLineColor = "DarkGreen"; var itemsAndNamesColor = "SteelBlue"; var clustersAndDimensionsFontcolor = "DarkOliveGreen" } var groups = new Array(clustermaxn); var groupsn = new Array(clustermaxn); var groupsd = new Array(clustermaxn); for (var n = 1; n < clustermaxn + 1; n++) { groups[n] = new Array(itemmaxn.value); groupsn[n] = new Array(itemmaxn.value); groupsd[n] = new Array(5); for (var nn = 1; nn < clustermaxn + 1; nn++) { groups[n][nn] = new Array(clustermaxn.value) } } groups = groups2; groupsn = groupsn2; groupsd = groupsd2; var groupsOld = new Array(clustermaxn); for (var n = 1; n < clustermaxn + 1; n++) { groupsOld[n] = new Array(itemmaxn.value) } var sheetNumber = 0; var rateToUse = 1; var participantmaxn = 200; var partx_orig = new Array(participantmaxn.value); var party_orig = new Array(participantmaxn.value); var partgx_orig = new Array(participantmaxn.value); var partgy_orig = new Array(participantmaxn.value); var clusterNameNow = new Array(clustermaxn); var clusternShown = 12; var groupsX = new Array(clustermaxn); var groupsY = new Array(clustermaxn); var clusterHeigth1 = new Array(clustermaxn); var clusterHeigth2 = new Array(clustermaxn); for (var n = 1; n < clustermaxn + 1; n++) { groupsX[n] = new Array(itemmaxn.value); groupsY[n] = new Array(itemmaxn.value); clusterHeigth1[n] = new Array(itemmaxn.value); clusterHeigth2[n] = new Array(itemmaxn.value) } var i, d, c, g, r; var zeroX = 0; var zeroY = 0; var itemcluster = new Array(cardn.value); var itemwx = new Array(cardn.value); var itemwy = new Array(cardn.value); var itemwz = new Array(cardn.value); var itemxx = new Array(cardn.value); var itemyy = new Array(cardn.value); var cardx = new Array(cardn.value); var cardy = new Array(cardn.value); var cardwx = new Array(cardn.value); var cardwy = new Array(cardn.value); var cardwz = new Array(cardn.value); var clusterx = new Array(clustermaxn.value); var clustery = new Array(clustermaxn.value); var clusterxl = new Array(clustermaxn.value); var clusteryl = new Array(clustermaxn.value); var clusterxw = new Array(clustermaxn.value); var clusteryw = new Array(clustermaxn.value); for (var n = 1; n < clustermaxn + 1; n++) { clusterx[n] = new Array(clustermaxn.value); clustery[n] = new Array(clustermaxn.value); clusterxl[n] = new Array(clustermaxn.value); clusteryl[n] = new Array(clustermaxn.value); clusterxw[n] = new Array(clustermaxn.value); clusteryw[n] = new Array(clustermaxn.value) } var clusterxx = new Array(clustermaxn.value); var clusteryy = new Array(clustermaxn.value); var clusterxxl = new Array(clustermaxn.value); var clusteryyl = new Array(clustermaxn.value); var clusterxxw = new Array(clustermaxn.value); var clusteryyw = new Array(clustermaxn.value); var clusterdist = new Array(clustermaxn); for (var n = 1; n < clustermaxn + 1; n++) { clusterxx[n] = new Array(clustermaxn.value); clusteryy[n] = new Array(clustermaxn.value); clusterxxl[n] = new Array(clustermaxn.value); clusteryyl[n] = new Array(clustermaxn.value); clusterxxw[n] = new Array(clustermaxn.value); clusteryyw[n] = new Array(clustermaxn.value); clusterdist[n] = new Array(clustermaxn); for (var nn = 1; nn < clustermaxn + 1; nn++) { clusterdist[n][nn] = new Array(clustermaxn) } } var pXsize = 0; var pYsize = 0; var itemselect = new Array(cardn.value); var yellow = new Array(clustermaxn); var yellowh = new Array(clustermaxn); for (var r = 1; r < clustermaxn + 1; r++) { yellowh[r] = new Array(3) } var mapClusersFromG = new Array(clustermaxn); var mapClusersFromR = new Array(clustermaxn); var cardxn; var cardyn; var cardxd = 0; var cardyd = 0; var startmove = 0; var clusterxn; var clusteryn; var worldsize; var worldcenterx; var worldcentery; var boxMwithin = 60; var boxMcorner = 40; var wmy = 9; var wmx = 9; var wamy = 11; var graphPositionH = new Array(cardn.value); var pilWC = new Array(clustern.value); var pihWC = new Array(clustern.value); var pilName = new Array(clustern.value); var pihName = new Array(clustern.value); var clusterwx = new Array(clustern.value); var mxWC3 = new Array(clustern.value); var myWC3 = new Array(clustern.value); var mxAbsWC = new Array(clustern.value); var myAbsWC = new Array(clustern.value); var lenAbsWC = new Array(clustern.value); for (var n = 1; n < clustermaxn + 1; n++) { pilWC[n] = new Array(clustermaxn.value); pihWC[n] = new Array(clustermaxn.value); pilName[n] = new Array(clustermaxn.value); pihName[n] = new Array(clustermaxn.value); clusterwx[n] = new Array(clustermaxn.value); mxWC3[n] = new Array(clustermaxn.value); myWC3[n] = new Array(clustermaxn.value); mxAbsWC[n] = new Array(clustermaxn.value); myAbsWC[n] = new Array(clustermaxn.value); lenAbsWC[n] = new Array(clustermaxn.value); graphPositionH[n] = new Array(clustermaxn.value); for (var nn = 1; nn < clustermaxn + 1; nn++) { graphPositionH[n][nn] = new Array(itemmaxn.value) } } var wordsused = new Array(999); var wordsusedn = new Array(999); var wordsusedx = new Array(999); var wordsusedy = new Array(999); var wordsusednow = 0; var ccw = new Array(11); for (c = 1; c < 10 + 1; c++) { ccw[c] = document.createElement("canvas"); document.body.appendChild(ccw[c]); ccw[c].style.position = "absolute"; ccw[c].style.visibility = "hidden"; ccw[c].width = 1; ccw[c].height = 1; ccw[c].style.top = 1 + "px"; ccw[c].style.left = 1 + "px" } var loadExampleData = function () { var t; var n = { option: "{\n" + "  gridSize: 12,\n" + "  weightFactor: 3,\n" + "  origin: [400, 200],\n" + "  clearCanvas: true,\n" + "  fontFamily: 'Calibri',\n" + "  color: '#f0f0c0',\n" + "  click: function(item) {\n" + "    alert(item[0] + ': ' + item[1]);\n" + "  },\n" + "  backgroundColor: '#001f00'\n" + "}" }; t = n.option; return t };